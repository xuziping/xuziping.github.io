---
layout: post
title: 一种基于字符串的压缩方式
categories: 加解密
description: 字符串压缩算法
keywords: 加解密,压缩
---


### 业务背景

项目中要基于**字段A和字段B组合作为唯一索引**，并且**生成一段六位的随机码（大小写字母+数字）**，**保证随机码在整个库中是不重复的**。目前库中大概有数十万条记录**要求全部一次性生成随机码**。可以预知的，在未来记录仍然将是不断累积增长，随机码始终要求唯一，并且每次都假定大约数十万的规模。

我们可以把这个随机码视作业务主键，对长度有比较严格的控制——因为该随机码要提供给客户登录使用。

### 解决方案之一：布隆过滤器

这个方案是目前已有的实现，完全能够正常工作。

首先把库里已有的所有随机码hash到布隆过滤器中。然后针对每条记录，随机生成一个六位的由大小写字母以及数字组成的随机码，并且通过布隆过滤器检查是否已经存在。

由于是生成时检测，因此就算有误判也不会有太大问题，重新生成即可。唯一可虑的是，每次生成作业属于突发性的，需要把历史记录hash进布隆过滤器中，会有一个加载时间；另外在多线程并发生成的情境下，在验证过程中需要考虑多线程并发的问题。

### 解决方案之二：类似于JWT的携带信息体进行压缩编码

还有一种方案，类似于JWT，把作为唯一索引的字段A和字段B的组合进行编码，然后尽可能压缩到理想的长度范围。在使用的时候解码即可。

这种方案所生成的字符串由于是无损压缩，所以理论上是能够保证其唯一性的。并且事实上，它不是一种“随机”算法，因此其输入（字段A和字段B的值）决定了它最终的输出值（随机码）。

基于这种思路，我去搜了下字符串的压缩，竟发现常规字符串（大小写字母+数字）压缩成字符串的算法不多见。网上能找到常见的还是大学课本上类似 AAABBCD=A3B2CD行程编码（RLE)，以及哈夫曼算法，前者压缩性欠缺，后者每次都会有动态字典，我觉得并不符合需求。另外看了散列表是否有可以利用的，但毕竟会有冲突，因此也作罢了。

自己简单设计一套：

**已知：**

1. 基于输入项只有大小写字母和数字（26*2+9=61），因此6位byte （64种可能性）即可完全覆盖
2. 如果输入字符串总长度位数是20个字符，那么一个字符占两个字节，一个字节8位byte计算，需要 320byte；但事实上英文和数字只需要一个字节8位byte即可，那么也就是160byte
3. 假定目前对 WP0ZZZ97ZEL000484520 进行编码

**设计：**

1. 输出首先以 3位byte 作为起始头部，标记其算法版本（稍后有用）
2.   在每标记一个字符前，先判断其是否为特殊字符，然后用 1位 byte 标记：  0 非特殊， 1  特殊
3.   对于非特殊字符（26*2）使用 6位byte 标记
4.   对于特殊字符，后继续跟 1位byte 标记特殊类型： 0 字典字符，1 重复字符
5.   跟在特殊字符标记位 以及 特殊类型标记位 之后的是 2~4位byte（根据起始头部的算法版本定制）
	* 如果特殊类型标记为 字典：那么这里取值可以是 2~4位byte 指定字典中的字典项位置（4~16个字典项）
	* 如果特殊类标记额为 重复：那么这里取值可以试 0~2位byte 指定或者不指定重复的是哪一个位置上的字符

**举例：**

> 对WP0ZZZ97ZEL000484 和 520 进行压缩，并且确认此类字符串只可能存在数字和大写字母

1. 直接拼接 WP0ZZZ97ZEL000484520

2. 由于确认只有大写字母和数字，总计36个字符。这些字符分别由字典字符（3位byte)8个以及常规字符（5位byte) 28个组成

   约定 压缩算法版本1：

   1. 压缩算法版本号

      000

      

   2. 标记位

      |                                     |                                      |                                                              |
      | ----------------------------------- | ------------------------------------ | ------------------------------------------------------------ |
      | 0 - 后跟常见字符（常见字符位数5位） | 10 - 后跟字典字符（字典字符位数3位） | 11 - 后跟重复字符 （2位）: 00 表示上上一位字符重复出现，01 表示 上一个字符重复出现 1次，10 表示 上一个字符重复出现 2次， 11 表述上一个字符重复出现3次 |

      

   3. 字典

      WP是常规代码，常见数字0，2，4，8计入字典，常见字母A，E，Z计入字典

      （以上根据业务和大批量数据中的字母和数字出现频次设定，也可以通过不同压缩算法版本进行适配）

      |        |       |       |       |
      | ------ | ----- | ----- | ----- |
      | WP=000 | 0=001 | 2=010 | 4=011 |
      | 8=100  | A=101 | E=110 | Z=111 |

      

   4. 常见字符

      |             |             |             |           |              |           |
      | ----------- | ----------- | ----------- | --------- | ------------ | --------- |
      | A（字典中） | B = 00110   | C = 00111   | D = 01000 | E （字典中） | F = 01001 |
      | G = 01010   | H = 01011   | I = 01100   | J = 01101 | K= 01110     | L = 01111 |
      | M = 10000   | N = 10001   | P = 10010   | Q = 10011 | R = 10100    | S = 10101 |
      | S = 10110   | T = 10111   | V = 11000   | W = 11001 | X = 11010    | Y = 11011 |
      | Y = 11100   | Z（字典中） |             |           |              |           |
      | 0（字典中） | 1 = 00000   | 2（字典中） | 3 = 00001 | 4（字典中）  | 5 = 00010 |
      | 6 = 00011   | 7 = 00100   | 8（字典中） | 9 = 00101 |              |           |

      

   5. 依次对 WP0ZZZ97ZEL000484520 字符串进行解析

      000   +   10       +  000   + 10       + 001 + 10       +   111 +   11     + 10   +  0       +  00101   +   0       +  00100  +

      版本  +   标记    +  WP   + 标记    + 0     + 标记    +   Z      +  标记  + ZZ   +  标记  +  9            +  标记  +   7          +

      => 继续

      10      +  111  +  10     +   110  + 0      +  01111  +  10       +   001  + 11      + 10   + 10      + 011   +   10       +

      标记   +  Z      +  标记  +   E      + 标记 +  L          +   标记    +  0       + 标记   + 00   + 标记  + 4        +  标记     + 

      => 继续

      100  +   11     +  00  + 0        + 00010 + 10     +   010  +  10    + 001

      8       +  标记  +  4    + 标记   + 5          + 标记  +   2     +  标记  + 0

​			获得最终压缩结果：   00010000100011011111100001010001001011110110001111100011110100111010011000000101001010001



		6. 对压缩结果进行对齐到6的倍数。通过添加3位标识需要多扩几位才能达到6的整数倍长度。如上89位长度，需加上3位标识长度的扩充，即92位再加4位扩充，如下

100 +  0000 + 00010000100011011111100001010001001011110110001111100011110100111010011000000101001010001

最终获得：

100000    000010    000100     011011    111100    001010    001001    011110    110001    111100    011110    100111    010011    000000    101001    010001



​	7. 最终获得一个16位的字符串，只能说效果不尽如人意...  :(








