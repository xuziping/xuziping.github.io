---
layout: post
title: 一种基于字符串的压缩方式
categories: 加解密
description: 字符串压缩算法
keywords: 加解密,压缩
---


### 业务背景

项目中要基于**字段A和字段B组合作为唯一索引**，并且**生成一段六位的随机码（大小写字母+数字）**，**保证随机码在整个库中是不重复的**。目前库中大概有数十万条记录**要求全部一次性生成随机码**。可以预知的，在未来记录仍然将是不断累积增长，随机码始终要求唯一，并且每次都假定大约数十万的规模。

我们可以把这个随机码视作业务主键，只是对长度有比较严格的控制——因为该随机码要提供给客户登录使用。

### 解决方案之一：布隆过滤器
	
这个方案是目前已有的实现，完全能够正常工作。

首先把库里已有的所有随机码hash到布隆过滤器中。然后针对每条记录，随机生成一个六位的由大小写字母以及数字组成的随机码，并且通过布隆过滤器检查是否已经存在。

由于是生成时检测，因此就算有误判也不会有太大问题，只不过重新生成即可。唯一可虑的是，每次生成作业属于突发性的，需要把历史记录hash进布隆过滤器中；另外在多线程并发生成的情境下，在验证过程中可能需要加锁操作。

### 解决方案之二：类似于JWT的携带信息体进行压缩编码

还有一种方案，类似于JWT，把作为唯一索引的字段A和字段B的组合进行编码，然后尽可能压缩到理想的长度范围。在使用的时候解码即可。

这种方案所生成的字符串由于是无损压缩，所以理论上是能够保证其唯一性的。并且事实上，它不是一种“随机”算法，因此其输入（字段A和字段B的值）决定了它最终的输出值（随机码）。

基于这种思路，我去搜了下字符串的压缩，竟发现常规字符串（大小写字母+数字）压缩成字符串的算法不多见。网上能找到常见的还是大学课本上的 AAABBCD=A3B2CD，以及哈夫曼算法，前者压缩性欠缺，后者每次都会有动态字典，我觉得并不符合需求。另外看了散列表是否有可以利用的，但毕竟会有冲突，因此也作罢了。

自己设计一套罢：

**已知：**

1. 基于输入项只有大小写字母和数字（26*2+9=61），因此6位byte （64种可能性）即可完全覆盖
2. 如果输入字符串总长度位20个字符，那么一个字符占两个字节，一个字节8位byte计算，需要 320byte；但事实上英文和数字只需要一个字节8位byte即可，那么也就是160byte
3. 假定目前对 WP0ZZZ97ZEL000484520 进行编码

**设计：**

1. 输出首先以 3位byte 作为起始头部，标记其算法版本（稍后有用）
2.   在每标记一个字符前，先判断其是否为特殊字符，然后用 1位 byte 标记：  0 非特殊， 1  特殊
3.   对于非特殊字符（26*2）使用 6位byte 标记
4.   对于特殊字符，后继续跟 1位byte 标记特殊类型： 0 字典字符，1 重复字符
5.   跟在特殊字符标记位 以及 特殊类型标记位 之后的是 2~4位byte（根据起始头部的算法版本定制）
	* 如果特殊类型标记为 字典：那么这里取值可以是 2~4位byte 指定字典中的字典项位置（4~16个字典项）
	* 如果特殊类标记额为 重复：那么这里取值可以试 0~2位byte 指定或者不指定重复的是哪一个位置上的字符








